// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ValeryCherneykin/taskanalytics/file_processing/internal/repository.UploadedFileRepository -o uploaded_file_repository_minimock.go -n UploadedFileRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/ValeryCherneykin/taskanalytics/file_processing/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UploadedFileRepositoryMock implements mm_repository.UploadedFileRepository
type UploadedFileRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, file *model.UploadedFile) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, file *model.UploadedFile)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUploadedFileRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUploadedFileRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.UploadedFile, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUploadedFileRepositoryMockGet

	funcList          func(ctx context.Context, limit uint64, offset uint64) (upa1 []*model.UploadedFile, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, limit uint64, offset uint64)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mUploadedFileRepositoryMockList

	funcUpdate          func(ctx context.Context, file *model.UploadedFile) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, file *model.UploadedFile)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUploadedFileRepositoryMockUpdate
}

// NewUploadedFileRepositoryMock returns a mock for mm_repository.UploadedFileRepository
func NewUploadedFileRepositoryMock(t minimock.Tester) *UploadedFileRepositoryMock {
	m := &UploadedFileRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUploadedFileRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UploadedFileRepositoryMockCreateParams{}

	m.DeleteMock = mUploadedFileRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UploadedFileRepositoryMockDeleteParams{}

	m.GetMock = mUploadedFileRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UploadedFileRepositoryMockGetParams{}

	m.ListMock = mUploadedFileRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*UploadedFileRepositoryMockListParams{}

	m.UpdateMock = mUploadedFileRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UploadedFileRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUploadedFileRepositoryMockCreate struct {
	optional           bool
	mock               *UploadedFileRepositoryMock
	defaultExpectation *UploadedFileRepositoryMockCreateExpectation
	expectations       []*UploadedFileRepositoryMockCreateExpectation

	callArgs []*UploadedFileRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UploadedFileRepositoryMockCreateExpectation specifies expectation struct of the UploadedFileRepository.Create
type UploadedFileRepositoryMockCreateExpectation struct {
	mock               *UploadedFileRepositoryMock
	params             *UploadedFileRepositoryMockCreateParams
	paramPtrs          *UploadedFileRepositoryMockCreateParamPtrs
	expectationOrigins UploadedFileRepositoryMockCreateExpectationOrigins
	results            *UploadedFileRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UploadedFileRepositoryMockCreateParams contains parameters of the UploadedFileRepository.Create
type UploadedFileRepositoryMockCreateParams struct {
	ctx  context.Context
	file *model.UploadedFile
}

// UploadedFileRepositoryMockCreateParamPtrs contains pointers to parameters of the UploadedFileRepository.Create
type UploadedFileRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	file **model.UploadedFile
}

// UploadedFileRepositoryMockCreateResults contains results of the UploadedFileRepository.Create
type UploadedFileRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// UploadedFileRepositoryMockCreateOrigins contains origins of expectations of the UploadedFileRepository.Create
type UploadedFileRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originFile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUploadedFileRepositoryMockCreate) Optional() *mUploadedFileRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UploadedFileRepository.Create
func (mmCreate *mUploadedFileRepositoryMockCreate) Expect(ctx context.Context, file *model.UploadedFile) *mUploadedFileRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UploadedFileRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UploadedFileRepositoryMockCreateParams{ctx, file}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UploadedFileRepository.Create
func (mmCreate *mUploadedFileRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUploadedFileRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UploadedFileRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectFileParam2 sets up expected param file for UploadedFileRepository.Create
func (mmCreate *mUploadedFileRepositoryMockCreate) ExpectFileParam2(file *model.UploadedFile) *mUploadedFileRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UploadedFileRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.file = &file
	mmCreate.defaultExpectation.expectationOrigins.originFile = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UploadedFileRepository.Create
func (mmCreate *mUploadedFileRepositoryMockCreate) Inspect(f func(ctx context.Context, file *model.UploadedFile)) *mUploadedFileRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UploadedFileRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UploadedFileRepository.Create
func (mmCreate *mUploadedFileRepositoryMockCreate) Return(i1 int64, err error) *UploadedFileRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UploadedFileRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UploadedFileRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UploadedFileRepository.Create method
func (mmCreate *mUploadedFileRepositoryMockCreate) Set(f func(ctx context.Context, file *model.UploadedFile) (i1 int64, err error)) *UploadedFileRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UploadedFileRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UploadedFileRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UploadedFileRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUploadedFileRepositoryMockCreate) When(ctx context.Context, file *model.UploadedFile) *UploadedFileRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UploadedFileRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UploadedFileRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UploadedFileRepositoryMockCreateParams{ctx, file},
		expectationOrigins: UploadedFileRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UploadedFileRepository.Create return parameters for the expectation previously defined by the When method
func (e *UploadedFileRepositoryMockCreateExpectation) Then(i1 int64, err error) *UploadedFileRepositoryMock {
	e.results = &UploadedFileRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UploadedFileRepository.Create should be invoked
func (mmCreate *mUploadedFileRepositoryMockCreate) Times(n uint64) *mUploadedFileRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UploadedFileRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUploadedFileRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.UploadedFileRepository
func (mmCreate *UploadedFileRepositoryMock) Create(ctx context.Context, file *model.UploadedFile) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, file)
	}

	mm_params := UploadedFileRepositoryMockCreateParams{ctx, file}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UploadedFileRepositoryMockCreateParams{ctx, file}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UploadedFileRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.file != nil && !minimock.Equal(*mm_want_ptrs.file, mm_got.file) {
				mmCreate.t.Errorf("UploadedFileRepositoryMock.Create got unexpected parameter file, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originFile, *mm_want_ptrs.file, mm_got.file, minimock.Diff(*mm_want_ptrs.file, mm_got.file))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UploadedFileRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UploadedFileRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, file)
	}
	mmCreate.t.Fatalf("Unexpected call to UploadedFileRepositoryMock.Create. %v %v", ctx, file)
	return
}

// CreateAfterCounter returns a count of finished UploadedFileRepositoryMock.Create invocations
func (mmCreate *UploadedFileRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UploadedFileRepositoryMock.Create invocations
func (mmCreate *UploadedFileRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UploadedFileRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUploadedFileRepositoryMockCreate) Calls() []*UploadedFileRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UploadedFileRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UploadedFileRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UploadedFileRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UploadedFileRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UploadedFileRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUploadedFileRepositoryMockDelete struct {
	optional           bool
	mock               *UploadedFileRepositoryMock
	defaultExpectation *UploadedFileRepositoryMockDeleteExpectation
	expectations       []*UploadedFileRepositoryMockDeleteExpectation

	callArgs []*UploadedFileRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UploadedFileRepositoryMockDeleteExpectation specifies expectation struct of the UploadedFileRepository.Delete
type UploadedFileRepositoryMockDeleteExpectation struct {
	mock               *UploadedFileRepositoryMock
	params             *UploadedFileRepositoryMockDeleteParams
	paramPtrs          *UploadedFileRepositoryMockDeleteParamPtrs
	expectationOrigins UploadedFileRepositoryMockDeleteExpectationOrigins
	results            *UploadedFileRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UploadedFileRepositoryMockDeleteParams contains parameters of the UploadedFileRepository.Delete
type UploadedFileRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UploadedFileRepositoryMockDeleteParamPtrs contains pointers to parameters of the UploadedFileRepository.Delete
type UploadedFileRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UploadedFileRepositoryMockDeleteResults contains results of the UploadedFileRepository.Delete
type UploadedFileRepositoryMockDeleteResults struct {
	err error
}

// UploadedFileRepositoryMockDeleteOrigins contains origins of expectations of the UploadedFileRepository.Delete
type UploadedFileRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUploadedFileRepositoryMockDelete) Optional() *mUploadedFileRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UploadedFileRepository.Delete
func (mmDelete *mUploadedFileRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUploadedFileRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UploadedFileRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UploadedFileRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UploadedFileRepository.Delete
func (mmDelete *mUploadedFileRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUploadedFileRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UploadedFileRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UploadedFileRepository.Delete
func (mmDelete *mUploadedFileRepositoryMockDelete) ExpectIdParam2(id int64) *mUploadedFileRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UploadedFileRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UploadedFileRepository.Delete
func (mmDelete *mUploadedFileRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUploadedFileRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UploadedFileRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UploadedFileRepository.Delete
func (mmDelete *mUploadedFileRepositoryMockDelete) Return(err error) *UploadedFileRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UploadedFileRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UploadedFileRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UploadedFileRepository.Delete method
func (mmDelete *mUploadedFileRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UploadedFileRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UploadedFileRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UploadedFileRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UploadedFileRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUploadedFileRepositoryMockDelete) When(ctx context.Context, id int64) *UploadedFileRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UploadedFileRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UploadedFileRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UploadedFileRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UploadedFileRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UploadedFileRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UploadedFileRepositoryMockDeleteExpectation) Then(err error) *UploadedFileRepositoryMock {
	e.results = &UploadedFileRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UploadedFileRepository.Delete should be invoked
func (mmDelete *mUploadedFileRepositoryMockDelete) Times(n uint64) *mUploadedFileRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UploadedFileRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUploadedFileRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UploadedFileRepository
func (mmDelete *UploadedFileRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UploadedFileRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UploadedFileRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UploadedFileRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UploadedFileRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UploadedFileRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UploadedFileRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UploadedFileRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UploadedFileRepositoryMock.Delete invocations
func (mmDelete *UploadedFileRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UploadedFileRepositoryMock.Delete invocations
func (mmDelete *UploadedFileRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UploadedFileRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUploadedFileRepositoryMockDelete) Calls() []*UploadedFileRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UploadedFileRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UploadedFileRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UploadedFileRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UploadedFileRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UploadedFileRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUploadedFileRepositoryMockGet struct {
	optional           bool
	mock               *UploadedFileRepositoryMock
	defaultExpectation *UploadedFileRepositoryMockGetExpectation
	expectations       []*UploadedFileRepositoryMockGetExpectation

	callArgs []*UploadedFileRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UploadedFileRepositoryMockGetExpectation specifies expectation struct of the UploadedFileRepository.Get
type UploadedFileRepositoryMockGetExpectation struct {
	mock               *UploadedFileRepositoryMock
	params             *UploadedFileRepositoryMockGetParams
	paramPtrs          *UploadedFileRepositoryMockGetParamPtrs
	expectationOrigins UploadedFileRepositoryMockGetExpectationOrigins
	results            *UploadedFileRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UploadedFileRepositoryMockGetParams contains parameters of the UploadedFileRepository.Get
type UploadedFileRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// UploadedFileRepositoryMockGetParamPtrs contains pointers to parameters of the UploadedFileRepository.Get
type UploadedFileRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UploadedFileRepositoryMockGetResults contains results of the UploadedFileRepository.Get
type UploadedFileRepositoryMockGetResults struct {
	up1 *model.UploadedFile
	err error
}

// UploadedFileRepositoryMockGetOrigins contains origins of expectations of the UploadedFileRepository.Get
type UploadedFileRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUploadedFileRepositoryMockGet) Optional() *mUploadedFileRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UploadedFileRepository.Get
func (mmGet *mUploadedFileRepositoryMockGet) Expect(ctx context.Context, id int64) *mUploadedFileRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UploadedFileRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UploadedFileRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UploadedFileRepository.Get
func (mmGet *mUploadedFileRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUploadedFileRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UploadedFileRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UploadedFileRepository.Get
func (mmGet *mUploadedFileRepositoryMockGet) ExpectIdParam2(id int64) *mUploadedFileRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UploadedFileRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UploadedFileRepository.Get
func (mmGet *mUploadedFileRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUploadedFileRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UploadedFileRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UploadedFileRepository.Get
func (mmGet *mUploadedFileRepositoryMockGet) Return(up1 *model.UploadedFile, err error) *UploadedFileRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UploadedFileRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UploadedFileRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UploadedFileRepository.Get method
func (mmGet *mUploadedFileRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.UploadedFile, err error)) *UploadedFileRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UploadedFileRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UploadedFileRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UploadedFileRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUploadedFileRepositoryMockGet) When(ctx context.Context, id int64) *UploadedFileRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UploadedFileRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UploadedFileRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UploadedFileRepositoryMockGetParams{ctx, id},
		expectationOrigins: UploadedFileRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UploadedFileRepository.Get return parameters for the expectation previously defined by the When method
func (e *UploadedFileRepositoryMockGetExpectation) Then(up1 *model.UploadedFile, err error) *UploadedFileRepositoryMock {
	e.results = &UploadedFileRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UploadedFileRepository.Get should be invoked
func (mmGet *mUploadedFileRepositoryMockGet) Times(n uint64) *mUploadedFileRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UploadedFileRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUploadedFileRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UploadedFileRepository
func (mmGet *UploadedFileRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.UploadedFile, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UploadedFileRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UploadedFileRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UploadedFileRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UploadedFileRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UploadedFileRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UploadedFileRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UploadedFileRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UploadedFileRepositoryMock.Get invocations
func (mmGet *UploadedFileRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UploadedFileRepositoryMock.Get invocations
func (mmGet *UploadedFileRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UploadedFileRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUploadedFileRepositoryMockGet) Calls() []*UploadedFileRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UploadedFileRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UploadedFileRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UploadedFileRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UploadedFileRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UploadedFileRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUploadedFileRepositoryMockList struct {
	optional           bool
	mock               *UploadedFileRepositoryMock
	defaultExpectation *UploadedFileRepositoryMockListExpectation
	expectations       []*UploadedFileRepositoryMockListExpectation

	callArgs []*UploadedFileRepositoryMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UploadedFileRepositoryMockListExpectation specifies expectation struct of the UploadedFileRepository.List
type UploadedFileRepositoryMockListExpectation struct {
	mock               *UploadedFileRepositoryMock
	params             *UploadedFileRepositoryMockListParams
	paramPtrs          *UploadedFileRepositoryMockListParamPtrs
	expectationOrigins UploadedFileRepositoryMockListExpectationOrigins
	results            *UploadedFileRepositoryMockListResults
	returnOrigin       string
	Counter            uint64
}

// UploadedFileRepositoryMockListParams contains parameters of the UploadedFileRepository.List
type UploadedFileRepositoryMockListParams struct {
	ctx    context.Context
	limit  uint64
	offset uint64
}

// UploadedFileRepositoryMockListParamPtrs contains pointers to parameters of the UploadedFileRepository.List
type UploadedFileRepositoryMockListParamPtrs struct {
	ctx    *context.Context
	limit  *uint64
	offset *uint64
}

// UploadedFileRepositoryMockListResults contains results of the UploadedFileRepository.List
type UploadedFileRepositoryMockListResults struct {
	upa1 []*model.UploadedFile
	err  error
}

// UploadedFileRepositoryMockListOrigins contains origins of expectations of the UploadedFileRepository.List
type UploadedFileRepositoryMockListExpectationOrigins struct {
	origin       string
	originCtx    string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mUploadedFileRepositoryMockList) Optional() *mUploadedFileRepositoryMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) Expect(ctx context.Context, limit uint64, offset uint64) *mUploadedFileRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &UploadedFileRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &UploadedFileRepositoryMockListParams{ctx, limit, offset}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) ExpectCtxParam1(ctx context.Context) *mUploadedFileRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &UploadedFileRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectLimitParam2 sets up expected param limit for UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) ExpectLimitParam2(limit uint64) *mUploadedFileRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &UploadedFileRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.limit = &limit
	mmList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmList
}

// ExpectOffsetParam3 sets up expected param offset for UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) ExpectOffsetParam3(offset uint64) *mUploadedFileRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &UploadedFileRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.offset = &offset
	mmList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) Inspect(f func(ctx context.Context, limit uint64, offset uint64)) *mUploadedFileRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for UploadedFileRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by UploadedFileRepository.List
func (mmList *mUploadedFileRepositoryMockList) Return(upa1 []*model.UploadedFile, err error) *UploadedFileRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &UploadedFileRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &UploadedFileRepositoryMockListResults{upa1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the UploadedFileRepository.List method
func (mmList *mUploadedFileRepositoryMockList) Set(f func(ctx context.Context, limit uint64, offset uint64) (upa1 []*model.UploadedFile, err error)) *UploadedFileRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the UploadedFileRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the UploadedFileRepository.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the UploadedFileRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mUploadedFileRepositoryMockList) When(ctx context.Context, limit uint64, offset uint64) *UploadedFileRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("UploadedFileRepositoryMock.List mock is already set by Set")
	}

	expectation := &UploadedFileRepositoryMockListExpectation{
		mock:               mmList.mock,
		params:             &UploadedFileRepositoryMockListParams{ctx, limit, offset},
		expectationOrigins: UploadedFileRepositoryMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up UploadedFileRepository.List return parameters for the expectation previously defined by the When method
func (e *UploadedFileRepositoryMockListExpectation) Then(upa1 []*model.UploadedFile, err error) *UploadedFileRepositoryMock {
	e.results = &UploadedFileRepositoryMockListResults{upa1, err}
	return e.mock
}

// Times sets number of times UploadedFileRepository.List should be invoked
func (mmList *mUploadedFileRepositoryMockList) Times(n uint64) *mUploadedFileRepositoryMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of UploadedFileRepositoryMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mUploadedFileRepositoryMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_repository.UploadedFileRepository
func (mmList *UploadedFileRepositoryMock) List(ctx context.Context, limit uint64, offset uint64) (upa1 []*model.UploadedFile, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, limit, offset)
	}

	mm_params := UploadedFileRepositoryMockListParams{ctx, limit, offset}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.upa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := UploadedFileRepositoryMockListParams{ctx, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("UploadedFileRepositoryMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmList.t.Errorf("UploadedFileRepositoryMock.List got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmList.t.Errorf("UploadedFileRepositoryMock.List got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("UploadedFileRepositoryMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the UploadedFileRepositoryMock.List")
		}
		return (*mm_results).upa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, limit, offset)
	}
	mmList.t.Fatalf("Unexpected call to UploadedFileRepositoryMock.List. %v %v %v", ctx, limit, offset)
	return
}

// ListAfterCounter returns a count of finished UploadedFileRepositoryMock.List invocations
func (mmList *UploadedFileRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of UploadedFileRepositoryMock.List invocations
func (mmList *UploadedFileRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to UploadedFileRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mUploadedFileRepositoryMockList) Calls() []*UploadedFileRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*UploadedFileRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *UploadedFileRepositoryMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *UploadedFileRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to UploadedFileRepositoryMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to UploadedFileRepositoryMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mUploadedFileRepositoryMockUpdate struct {
	optional           bool
	mock               *UploadedFileRepositoryMock
	defaultExpectation *UploadedFileRepositoryMockUpdateExpectation
	expectations       []*UploadedFileRepositoryMockUpdateExpectation

	callArgs []*UploadedFileRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UploadedFileRepositoryMockUpdateExpectation specifies expectation struct of the UploadedFileRepository.Update
type UploadedFileRepositoryMockUpdateExpectation struct {
	mock               *UploadedFileRepositoryMock
	params             *UploadedFileRepositoryMockUpdateParams
	paramPtrs          *UploadedFileRepositoryMockUpdateParamPtrs
	expectationOrigins UploadedFileRepositoryMockUpdateExpectationOrigins
	results            *UploadedFileRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// UploadedFileRepositoryMockUpdateParams contains parameters of the UploadedFileRepository.Update
type UploadedFileRepositoryMockUpdateParams struct {
	ctx  context.Context
	file *model.UploadedFile
}

// UploadedFileRepositoryMockUpdateParamPtrs contains pointers to parameters of the UploadedFileRepository.Update
type UploadedFileRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	file **model.UploadedFile
}

// UploadedFileRepositoryMockUpdateResults contains results of the UploadedFileRepository.Update
type UploadedFileRepositoryMockUpdateResults struct {
	err error
}

// UploadedFileRepositoryMockUpdateOrigins contains origins of expectations of the UploadedFileRepository.Update
type UploadedFileRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originFile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Optional() *mUploadedFileRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UploadedFileRepository.Update
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Expect(ctx context.Context, file *model.UploadedFile) *mUploadedFileRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UploadedFileRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UploadedFileRepositoryMockUpdateParams{ctx, file}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UploadedFileRepository.Update
func (mmUpdate *mUploadedFileRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUploadedFileRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UploadedFileRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectFileParam2 sets up expected param file for UploadedFileRepository.Update
func (mmUpdate *mUploadedFileRepositoryMockUpdate) ExpectFileParam2(file *model.UploadedFile) *mUploadedFileRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UploadedFileRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UploadedFileRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.file = &file
	mmUpdate.defaultExpectation.expectationOrigins.originFile = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UploadedFileRepository.Update
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Inspect(f func(ctx context.Context, file *model.UploadedFile)) *mUploadedFileRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UploadedFileRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UploadedFileRepository.Update
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Return(err error) *UploadedFileRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UploadedFileRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UploadedFileRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the UploadedFileRepository.Update method
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Set(f func(ctx context.Context, file *model.UploadedFile) (err error)) *UploadedFileRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UploadedFileRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UploadedFileRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the UploadedFileRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUploadedFileRepositoryMockUpdate) When(ctx context.Context, file *model.UploadedFile) *UploadedFileRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UploadedFileRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UploadedFileRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &UploadedFileRepositoryMockUpdateParams{ctx, file},
		expectationOrigins: UploadedFileRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UploadedFileRepository.Update return parameters for the expectation previously defined by the When method
func (e *UploadedFileRepositoryMockUpdateExpectation) Then(err error) *UploadedFileRepositoryMock {
	e.results = &UploadedFileRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times UploadedFileRepository.Update should be invoked
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Times(n uint64) *mUploadedFileRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UploadedFileRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mUploadedFileRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.UploadedFileRepository
func (mmUpdate *UploadedFileRepositoryMock) Update(ctx context.Context, file *model.UploadedFile) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, file)
	}

	mm_params := UploadedFileRepositoryMockUpdateParams{ctx, file}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UploadedFileRepositoryMockUpdateParams{ctx, file}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UploadedFileRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.file != nil && !minimock.Equal(*mm_want_ptrs.file, mm_got.file) {
				mmUpdate.t.Errorf("UploadedFileRepositoryMock.Update got unexpected parameter file, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originFile, *mm_want_ptrs.file, mm_got.file, minimock.Diff(*mm_want_ptrs.file, mm_got.file))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UploadedFileRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UploadedFileRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, file)
	}
	mmUpdate.t.Fatalf("Unexpected call to UploadedFileRepositoryMock.Update. %v %v", ctx, file)
	return
}

// UpdateAfterCounter returns a count of finished UploadedFileRepositoryMock.Update invocations
func (mmUpdate *UploadedFileRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UploadedFileRepositoryMock.Update invocations
func (mmUpdate *UploadedFileRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UploadedFileRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUploadedFileRepositoryMockUpdate) Calls() []*UploadedFileRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UploadedFileRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UploadedFileRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UploadedFileRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UploadedFileRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to UploadedFileRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UploadedFileRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UploadedFileRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UploadedFileRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UploadedFileRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockListDone() &&
		m.MinimockUpdateDone()
}
